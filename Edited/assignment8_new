// RefactoredRoster.java
// BEFORE: legacy code used explicit loops, mutable lists, and anonymous Comparators.
// AFTER: methods rewritten using Java 8+ Streams, lambdas, and collectors.
// Each method below includes a brief commented "BEFORE" snippet followed by the
// refactored implementation and an inline comment highlighting the key change.

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class RefactoredRoster {

	// --- Simple domain model ---
	static class Course {
		private final String code;     // e.g., "CSC-101"
		private final String title;    // e.g., "Intro to CS"

		public Course(String code, String title) {
			this.code = code;
			this.title = title;
		}

		public String getCode() { return code; }
		public String getTitle() { return title; }

		@Override
		public String toString() {
			return code + " - " + title;
		}
	}

	static class Student {
		private final String id;
		private final String firstName;
		private final String lastName;
		private final String major;    // e.g., "CS", "SE", "IT"
		private final double gpa;      // 0.0 - 4.0
		private final int credits;     // accumulated credits
		private final String email;
		private final List<Course> courses; // enrolled courses (defensive copy)

		public Student(String id, String firstName, String lastName,
					   String major, double gpa, int credits, String email,
					   List<Course> courses) {
			this.id = id;
			this.firstName = firstName;
			this.lastName = lastName;
			this.major = major;
			this.gpa = gpa;
			this.credits = credits;
			this.email = email;
			// Keep defensive copy like original but expose as immutable view if needed.
			this.courses = new ArrayList<>(Objects.requireNonNullElse(courses, new ArrayList<>()));
		}

		public String getId() { return id; }
		public String getFirstName() { return firstName; }
		public String getLastName() { return lastName; }
		public String getMajor() { return major; }
		public double getGpa() { return gpa; }
		public int getCredits() { return credits; }
		public String getEmail() { return email; }
		public List<Course> getCourses() { return courses; }

		@Override
		public String toString() {
			return String.format("%s %s (ID:%s, %s) GPA: %.2f, Credits: %d",
					firstName, lastName, id, major, gpa, credits);
		}
	}

	// --- Refactored utility methods using Streams ---

	/**
	 * BEFORE (original):
	 *   // iterate, filter with if, add to result, then Collections.sort with anonymous Comparator
	 * AFTER: use stream(), filter(), sorted(), collect().
	 */
	public static List<Student> getHonorRoll(List<Student> students, double minGpa, int minCredits) {
		if (students == null) return new ArrayList<>();
		return students.stream()
				.filter(Objects::nonNull)
				.filter(s -> s.getGpa() >= minGpa && s.getCredits() >= minCredits)
				// case-insensitive last name then first name
				.sorted(Comparator.comparing(Student::getLastName, String.CASE_INSENSITIVE_ORDER)
						.thenComparing(Student::getFirstName, String.CASE_INSENSITIVE_ORDER))
				.collect(Collectors.toList()); // immutable list not required; preserves List contract
	}

	/**
	 * BEFORE: loop, null checks, add lowercase email to list, Collections.sort(emails)
	 * AFTER: stream -> filter -> map -> sorted -> collect
	 */
	public static List<String> getEmailsByMajor(List<Student> students, String major) {
		if (students == null || major == null) return new ArrayList<>();
		return students.stream()
				.filter(Objects::nonNull)
				.filter(s -> s.getMajor() != null && s.getEmail() != null)
				.filter(s -> s.getMajor().equalsIgnoreCase(major))
				.map(s -> s.getEmail().toLowerCase()) // map to lowercased email
				.sorted() // natural order
				.collect(Collectors.toList());
	}

	/**
	 * BEFORE: make copy with loop, sort with anonymous Comparator that compares GPA desc then credits desc,
	 *        then build top N by indexing.
	 * AFTER: stream, sort with Comparator composed and reversed, limit(n), collect.
	 */
	public static List<Student> getTopNByGpa(List<Student> students, int n) {
		if (students == null || n <= 0) return new ArrayList<>();
		return students.stream()
				.filter(Objects::nonNull)
				.sorted(Comparator.comparingDouble(Student::getGpa).reversed()
						.thenComparing(Comparator.comparingInt(Student::getCredits).reversed()))
				.limit(n)
				.collect(Collectors.toList());
	}

	/**
	 * BEFORE: explicit loop, sum, count, and divide with checks
	 * AFTER: mapToDouble + average().orElse(0.0)
	 */
	public static double getAverageGpa(List<Student> students) {
		if (students == null || students.isEmpty()) return 0.0;
		return students.stream()
				.filter(Objects::nonNull)
				.mapToDouble(Student::getGpa)
				.average()
				.orElse(0.0);
	}

	/**
	 * BEFORE: manual loop, equals(id) checks
	 * AFTER: stream().filter(...).findFirst().orElse(null)
	 */
	public static Student findById(List<Student> students, String id) {
		if (students == null || id == null) return null;
		return students.stream()
				.filter(Objects::nonNull)
				.filter(s -> s.getId() != null && s.getId().equals(id))
				.findFirst()
				.orElse(null);
	}

	/**
	 * BEFORE: nested loops, HashSet to dedupe, Collections.sort with case-insensitive Comparator
	 * AFTER: flatMap courses -> map titles -> distinct -> sorted(case-insensitive) -> collect
	 */
	public static List<String> getDistinctCourseTitles(List<Student> students) {
		if (students == null) return new ArrayList<>();
		return students.stream()
				.filter(Objects::nonNull)
				.flatMap(s -> s.getCourses() == null ? Stream.empty() : s.getCourses().stream())
				.filter(Objects::nonNull)
				.map(Course::getTitle)
				.filter(Objects::nonNull)
				.map(String::trim)
				.distinct() // removes duplicates
				.sorted(String.CASE_INSENSITIVE_ORDER)
				.collect(Collectors.toList());
	}

	// --- Demo data and output (keeps same behavior as original main) ---
	public static void main(String[] args) {
		Course csc101 = new Course("CSC-101", "Intro to CS");
		Course csc225 = new Course("CSC-225", "Data Structures");
		Course csc372 = new Course("CSC-372", "Generative AI");
		Course mat250 = new Course("MAT-250", "Discrete Math");
		Course se310  = new Course("SE-310",  "Software Engineering");

		List<Student> roster = new ArrayList<>();
		List<Course> aCourses = new ArrayList<>();
		aCourses.add(csc101); aCourses.add(csc225); aCourses.add(mat250);

		List<Course> bCourses = new ArrayList<>();
		bCourses.add(csc225); bCourses.add(se310);

		List<Course> cCourses = new ArrayList<>();
		cCourses.add(csc101); cCourses.add(csc372); cCourses.add(se310); cCourses.add(csc225);

		roster.add(new Student("A001", "Emma",  "Rowe",        "CS", 3.82, 78, "emma.rowe@univ.edu", aCourses));
		roster.add(new Student("A002", "Noah",  "Turner",      "SE", 3.10, 45, "noah.turner@univ.edu", bCourses));
		roster.add(new Student("A003", "Xander","Wood",        "CS", 3.95, 90, "xander.wood@univ.edu", cCourses));
		roster.add(new Student("A004", "Ethan", "Sexton",      "IT", 2.75, 30, "ethan.sexton@univ.edu", aCourses));
		roster.add(new Student("A005", "Jolie", "Barger",      "CS", 3.35, 60, "jolie.barger@univ.edu", bCourses));
		roster.add(new Student("A006", "Sravani","Kadiyala",   "SE", 3.55, 72, "sravani.k@univ.edu",    cCourses));

		List<Student> honor = getHonorRoll(roster, 3.5, 60);
		System.out.println("Honor Roll:");
		honor.forEach(s -> System.out.println(" - " + s));

		List<String> csEmails = getEmailsByMajor(roster, "CS");
		System.out.println("\nCS Emails (sorted):");
		csEmails.forEach(e -> System.out.println(" - " + e));

		List<Student> top3 = getTopNByGpa(roster, 3);
		System.out.println("\nTop 3 by GPA:");
		top3.forEach(s -> System.out.println(" - " + s));

		double avg = getAverageGpa(roster);
		System.out.println("\nAverage GPA: " + String.format("%.3f", avg));

		Student found = findById(roster, "A003");
		System.out.println("\nfindById('A003'): " + (found == null ? "not found" : found.toString()));

		List<String> titles = getDistinctCourseTitles(roster);
		System.out.println("\nDistinct course titles (sorted, case-insensitive):");
		titles.forEach(t -> System.out.println(" - " + t));
	}
}

